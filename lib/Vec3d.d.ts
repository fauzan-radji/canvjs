import Mat4 from "./Mat4";
import Vec2d from "./Vec2d";
export default class Vec3d {
    private _x;
    private _y;
    private _z;
    private _theta;
    private _phi;
    private _magnitude;
    constructor(x: number, y: number, z: number);
    set(v: Vec3d): Vec3d;
    copy({ x, y, z }?: {
        x?: number;
        y?: number;
        z?: number;
    }): Vec3d;
    add(v: Vec3d): Vec3d;
    subtract(v: Vec3d): Vec3d;
    multiply(scalar: number): Vec3d;
    divide(scalar: number): Vec3d;
    dot(v: Vec3d): number;
    transform(m: Mat4): Vec3d;
    project(fieldOfView: number, aspectRatio: number, near: number, far: number, width: number, height: number): Vec2d;
    translate(v: Vec3d): Vec3d;
    rotateX(theta: number): Vec3d;
    rotateY(theta: number): Vec3d;
    rotateZ(theta: number): Vec3d;
    scale(v: Vec3d): Vec3d;
    normalize(): Vec3d;
    toVec2d(): Vec2d;
    set x(x: number);
    get x(): number;
    set y(y: number);
    get y(): number;
    set z(z: number);
    get z(): number;
    set theta(theta: number);
    get theta(): number;
    set phi(phi: number);
    get phi(): number;
    set magnitude(magnitude: number);
    get magnitude(): number;
    set r(r: number);
    get r(): number;
    static add(v1: Vec3d, v2: Vec3d): Vec3d;
    static subtract(v1: Vec3d, v2: Vec3d): Vec3d;
    static multiply(v: Vec3d, scalar: number): Vec3d;
    static divide(v: Vec3d, scalar: number): Vec3d;
    static dot(v1: Vec3d, v2: Vec3d): number;
    static cross(v1: Vec3d, v2: Vec3d): Vec3d;
    static transform(v: Vec3d, m: Mat4): Vec3d;
    static translate(v: Vec3d, translation: Vec3d): Vec3d;
    static rotateX(v: Vec3d, theta: number): Vec3d;
    static rotateY(v: Vec3d, theta: number): Vec3d;
    static rotateZ(v: Vec3d, theta: number): Vec3d;
    static scale(v: Vec3d, scale: Vec3d): Vec3d;
    static normalize(v: Vec3d): Vec3d;
    static fromPolar(theta: number, phi: number, magnitude: number): Vec3d;
}
